/*
 * main.c - TinyG - An embedded rs274/ngc CNC controller
 * This file is part of the TinyG project.
 *
 * Copyright (c) 2010 - 2016 Alden S. Hart, Jr.
 * Copyright (c) 2013 - 2016 Robert Giseburt
 *
 * This file ("the software") is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2 as published by the
 * Free Software Foundation. You should have received a copy of the GNU General Public
 * License, version 2 along with the software.  If not, see <http://www.gnu.org/licenses/>.
 *
 * THE SOFTWARE IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT WITHOUT ANY
 * WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
 * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/* See github.com/Synthetos/tinyg for code and docs on the wiki
 */

#include "tinyg.h"					// #1 There are some dependencies
#include "config.h"					// #2
#include "hardware.h"
#include "persistence.h"
#include "controller.h"
#include "canonical_machine.h"
#include "report.h"
#include "planner.h"
#include "stepper.h"
#include "encoder.h"
#include "spindle.h"
//#include "coolant.h"
#include "switch.h"     // #include "gpio.h"
#include "test.h"
#include "pwm.h"
#include "xio.h"

/******************** System Globals *************************/

stat_t status_code;						    // allocate a variable for the ritorno macro
char text_item[TEXT_ITEM_LEN];
char units_msg[UNITS_MSG_LEN];

static char _status_msg[STATUS_MSG_LEN];

/******************** Application Code ************************/



/*
 * _system_init()
 */

void _system_init(void)
{

}

/*
 * application_inits
 *
 * There are a lot of dependencies in the order of these inits.
 * Don't change the ordering unless you understand this.
 */

static void _application_init_services(void)
{
    hardware_init();				// FIRST:  system hardware setup
    persistence_init();				// SECOND: set up EEPROM or other NVM
    //xio_init();						// THIRD:  extended io subsystem

}

static void _application_init_machine(void)
{
    cm.machine_state = MACHINE_INITIALIZING;

	stepper_init(); 				// stepper subsystem - must precede gpio_init()
	encoder_init();					// virtual encoders
//    switch_init();                    // switches
//    gpio_init();                      // inputs and outputs
	pwm_init();						// pulse width modulation drivers - must follow gpio_init()
	planner_init();					// motion planning subsystem
	canonical_machine_init();		// canonical machine
}

static void _application_init_startup(void)
{
    // start the application
	controller_init(STD_IN, STD_OUT, STD_ERR);  // FIRST:  depends on xio_init()
	config_init();					            // SECOND: read config records from eeprom
	switch_init();                              // switch setup relies on config settings
	canonical_machine_reset();                  // depends on config_init()
    spindle_init();                             // depends on config_init()
    spindle_reset();



    // Note: system-ready message generated by controller.c
}

/*
 * main()
 */

int main(void)
{


	// system initialization
	_system_init();

	// TinyG application setup
	_application_init_services();
	_application_init_machine();
	_application_init_startup();
	run_canned_startup();			// run any pre-loaded commands

	// main loop
	for (;;) {
		controller_run( );			// single pass through the controller
	}
	return 0;
}

/*
 * get_status_message() - support for status messages.
 */

char *get_status_message(stat_t status)
{

	return (char *)(&stat_msg[status]);
}

void assert_failed(uint8_t* file, uint32_t line)
{
    while (1) ;
}

